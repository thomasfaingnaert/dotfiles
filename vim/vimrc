" --------------------------------------------------------------------------------
" Plugin list
" --------------------------------------------------------------------------------

call plug#begin()

Plug 'iCyMind/NeoSolarized'

if has('python3') | Plug 'SirVer/ultisnips' | endif
Plug 'honza/vim-snippets'

Plug 'tpope/vim-commentary'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-projectionist'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-rhubarb'
Plug 'tpope/vim-unimpaired'

Plug 'lervag/vimtex'
Plug 'machakann/vim-sandwich'
Plug 'junegunn/vim-easy-align'

Plug 'christoomey/vim-sort-motion'
Plug 'markonm/traces.vim'

Plug 'prabirshrestha/asyncomplete.vim'
Plug 'prabirshrestha/async.vim'
Plug 'prabirshrestha/vim-lsp'
Plug 'prabirshrestha/asyncomplete-lsp.vim'

Plug 'thomasfaingnaert/vim-lsp-snippets'
Plug 'thomasfaingnaert/vim-lsp-ultisnips'

Plug 'vim-scripts/DoxygenToolkit.vim'

call plug#end()

" --------------------------------------------------------------------------------
" General settings
" --------------------------------------------------------------------------------

"" Setup
" Load matchit
if !has('nvim') | packadd! matchit | endif

" Enable filetype support and syntax highlighting
filetype plugin indent on
syntax enable

"" GUI options
if has('gui_running')
    set background=light
    colorscheme NeoSolarizedCustom

    " Only set guifont once, since it resizes gVim when sourcing $MYVIMRC
    if !exists('s:set_guifont')
        let s:set_guifont = 1

        if has('win32')
            set guifont=Consolas:h11
        else
            set guifont=Monospace\ 11
        endif
    endif

    set guioptions-=m
    set guioptions-=T
    set guioptions-=r
    set guioptions-=L
endif

"" System-dependent settings
""" Temporary directories
if !exists('s:myruntime')
    let s:myruntime = split(&runtimepath, ',')[0]
end

let &backupdir = s:myruntime . '/backup//'
let &directory = s:myruntime . '/swap//'
let &undodir = s:myruntime . '/undo//'

""" Dotfiles
if !exists('g:mydotfiles')
    if has('win32')
        let g:mydotfiles = '~/dotfiles'
    else
        let g:mydotfiles = '~/.dotfiles'
    endif
end

"" Line numbers
set relativenumber
set number

"" Indentation
set shiftwidth=4
set softtabstop=4
set expandtab
set autoindent
set shiftround

"" Search
set hlsearch
set incsearch
set ignorecase
set smartcase

"" Statusline
set laststatus=2

set statusline=                             " clear statusline for when vimrc is reloaded
set statusline+=%f                          " path to file in the buffer
set statusline+=%(\ %h%)                    " help flag: [Help] or empty
set statusline+=%(\ %m%)                    " modified flag: [+] or [-] or empty
set statusline+=%(\ %r%)                    " readonly flag: [RO] or empty
set statusline+=%(\ (%{fugitive#head()})%)  " current branch
set statusline+=%=                          " right align
set statusline+=\ Line:\ %l/%L              " current line and total number of lines
set statusline+=\ Col:\ %c                  " column number

"" Other
set encoding=utf-8
set listchars=eol:¬,tab:▸\ ,trail:·,precedes:←,extends:→
set backspace=indent,eol,start
set wildmenu
set wildcharm=<C-z>
set scrolloff=5
set sidescrolloff=5
set formatoptions+=j
set hidden
set lazyredraw
set autoread
set showcmd
set spelllang=en_gb
set nrformats-=octal
set path+=**

" This fixes netrw-gx and :Gbrowse not working in gVim
let g:netrw_browsex_viewer="setsid xdg-open"

" Set shell to cmd.exe (this is needed to use gVim as difftool in Windows)
if has('win32')
    set shell=C:\WINDOWS\system32\cmd.exe
endif

"" Set wildignore
set wildignore+=*/build/*
set wildignore+=*/docs/*

" --------------------------------------------------------------------------------
" Plugin settings
" --------------------------------------------------------------------------------

"" UltiSnips
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"
let g:UltiSnipsEditSplit = "vertical"

"" vim-tex
" Use LaTeX by default
let g:tex_flavor = "latex"

" Don't automatically open/close the quickfix window in tex files
" When using autowrite and latexmk pvc, it is annoying and it breaks
" UltiSnips
let g:vimtex_quickfix_mode = 0

" Use SumatraPDF in Windows
if has('win32')
    let g:vimtex_view_general_viewer = 'SumatraPDF'
    let g:vimtex_view_general_options
                \ = '-reuse-instance -forward-search @tex @line @pdf'
                \ . ' -inverse-search "' . $VIMRUNTIME . '\gvim.exe --servername ' . v:servername
                \ . ' --remote-silent +\%l \%f"'
    let g:vimtex_view_general_options_latexmk = '-reuse-instance'
endif

"" vim-sandwich
" I prefer vim-surround keymappings
runtime macros/sandwich/keymap/surround.vim

"" vim-sort-motion
" Ignore options when sorting \usepackage in LaTeX
let g:sort_motion_flags = ''
            \ . '/'
            \ .     '\('
            \ .         '^\\usepackage'
            \ .         '\('
            \ .             '\['
            \ .             '[^\]]*'
            \ .             '\]'
            \ .         '\)\?'
            \ .         '{'
            \ .     '\)\?'
            \ . '/'

"" vim-projectionist
let g:projectionist_heuristics = {
            \   "include/*.h|src/*.cpp": {
            \       "include/*.h": {
            \           "alternate": "src/{}.cpp",
            \           "type": "header"
            \       },
            \       "src/*.cpp": {
            \           "alternate": "include/{}.h",
            \           "type": "source"
            \       }
            \   },
            \   "*.h&*.cpp": {
            \       "*.h": {
            \           "alternate": "{}.cpp",
            \           "type": "header"
            \       },
            \       "*.cpp": {
            \           "alternate": "{}.h",
            \           "type": "source"
            \       }
            \   }}

" --------------------------------------------------------------------------------
" Mappings
" --------------------------------------------------------------------------------

"" Allow undoing C-u and C-w in insert mode
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>

"" Window navigation and movement
nnoremap <silent> <C-h> :call window_move#window_move('h')<CR>
nnoremap <silent> <C-j> :call window_move#window_move('j')<CR>
nnoremap <silent> <C-k> :call window_move#window_move('k')<CR>
nnoremap <silent> <C-l> :call window_move#window_move('l')<CR>

nnoremap <C-M-h> <C-w>H
nnoremap <C-M-j> <C-w>J
nnoremap <C-M-k> <C-w>K
nnoremap <C-M-l> <C-w>L

"" Move lines up and down
nnoremap <A-j> :move +1<CR>==
nnoremap <A-k> :move -2<CR>==

inoremap <A-j> <Esc>:move +1<CR>==gi
inoremap <A-k> <Esc>:move -2<CR>==gi

xnoremap <A-j> :move '>+1<CR>gv=gv
xnoremap <A-k> :move '<-2<CR>gv=gv

"" Leader
let mapleader = " "
let maplocalleader = "\\"

nnoremap <leader>e :browse edit<CR>
nnoremap <leader>w :update<CR>
nnoremap <leader>v :execute ':edit ' . g:mydotfiles . '/vim/vimrc'<CR>
nnoremap <leader>r :source $MYVIMRC<CR>
nnoremap <leader>l :set list!<CR>
nnoremap <leader>h :nohlsearch<CR>
nnoremap <silent> <leader>= :call preserve_state#execute("silent normal gg=G")<CR>
nnoremap <leader>c :lcd %:h<CR>
nnoremap <leader>p :set spell!<CR>:set spell?<CR>

" Deselect selected wildmenu option, if any
cnoremap <expr> <SID>deselect_wildmenu_option wildmenumode() ? "\<S-Tab>" : ""

nmap <leader>b :ls<CR>:buffer <C-z><SID>deselect_wildmenu_option
nmap <leader>s :ls<CR>:vert sbuffer <C-z><SID>deselect_wildmenu_option
nmap <leader>d :ls<CR>:bdelete <C-z><SID>deselect_wildmenu_option

"" Fugitive
nnoremap <leader>gs :Gstatus<CR>
nnoremap <leader>ge :Gedit<CR>
nnoremap <leader>gw :Gwrite<CR>
nnoremap <leader>gr :Gread<CR>
nnoremap <leader>gp :Gpush<CR>
nnoremap <leader>gc :Glcd<CR>
nnoremap <leader>gb :Gbrowse<CR>

"" Easy align
nmap ga <Plug>(EasyAlign)
xmap ga <Plug>(EasyAlign)

"" Make
nnoremap <silent> <F7> :call make_application#make_application()<CR>

"" Emacs-style command-line editing
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-n> <Down>
cnoremap <C-p> <Up>

"" Faster search and replace
nmap <silent> <Space><Space> :call <SID>save_word()<CR>:set operatorfunc=<SID>quick_replace<CR>g@
vmap <silent> <Space><Space> :<C-u>call <SID>quick_replace(visualmode(), 1)<CR>

nnoremap v :call <SID>save_word()<CR>v
nnoremap V :call <SID>save_word()<CR>V
nnoremap <C-v> :call <SID>save_word()<CR><C-v>

function! s:save_word()
    let s:word = expand('<cword>')
endfunction

function! s:quick_replace(type, ...)
    if a:0
        call feedkeys(":'<,'>s/\\<" . s:word . "\\>//g\<Left>\<Left>")
    else
        call feedkeys(":'[,']s/\\<" . s:word . "\\>//g\<Left>\<Left>")
    endif
endfunction

"" Quickly switch between alternate files
nnoremap <expr> <BS> exists(':A') ? ':A<CR>' : '<C-^>'

"" Don't fill in completion with omnicompletion
inoremap <expr> <SID>completeopt_longest_off <SID>set_completeopt_longest(0)
inoremap <expr> <SID>completeopt_longest_on <SID>set_completeopt_longest(1)
inoremap <script> <C-x><C-o> <SID>completeopt_longest_on<C-x><C-o><SID>completeopt_longest_off

"" Increase and reset font size
nnoremap <M-+> :call font_size#increment(+1)<CR>
nnoremap <M--> :call font_size#increment(-1)<CR>
nnoremap <M-=> :call font_size#reset()<CR>

"" Format paragraph so all sentences are on a different line
nnoremap Q :set operatorfunc=format_paragraph#format_paragraph<CR>g@
vnoremap Q :<C-u>call format_paragraph#format_paragraph(visualmode(), 1)<CR>

"" Underline current line
nnoremap <silent> <leader>u :call underline#underline(0)<CR>
nnoremap <silent> <leader>U :call underline#underline(1)<CR>

"" Easy grep
nnoremap <silent> gr :silent grep! -r <cword> *<CR>

"" Prev/next match during incremental search
cnoremap <expr> <Tab> getcmdtype() == '/' \|\| getcmdtype() == '?' ? '<C-g>' : '<C-z>'
cnoremap <expr> <S-Tab> getcmdtype() == '/' \|\| getcmdtype() == '?' ? '<C-t>' : '<S-Tab>'

" --------------------------------------------------------------------------------
" Autocommands
" --------------------------------------------------------------------------------

"" Automatically strip whitespace
augroup strip_whitespace
    autocmd!
    autocmd BufWritePre * call preserve_state#execute("%s/\\s\\+$//e")
augroup end

"" LaTeX - autowrite files
augroup autowrite_latex_files
    autocmd!
    autocmd FileType tex autocmd! autowrite_latex_files CursorHold,CursorHoldI <buffer> call <SID>autowrite_latex()
augroup end

"" LaTeX - auto sort usepackage
augroup autosort_latex_usepackage
    autocmd!
    autocmd FileType tex autocmd! autosort_latex_usepackage BufWritePre <buffer> call preserve_state#execute('g/\n\n^\\usepackage/+2 normal gsip')
augroup end

"" Automatically source vimrc
augroup auto_source_vimrc
    autocmd!
    execute 'autocmd BufWritePost ' . g:mydotfiles . '/vim/vimrc' . ' source $MYVIMRC'
augroup end

"" Set folding for vimrc
augroup folding_vimrc
    autocmd!
    execute 'autocmd BufReadPre ' . g:mydotfiles . '/vim/vimrc setlocal foldmethod=expr foldexpr=VimrcFoldExpr() foldtext=VimrcFoldText()'
augroup end

"" Automatically open quickfix
augroup auto_open_quickfix
    autocmd!
    autocmd QuickFixCmdPost [^l]* nested cwindow
    autocmd QuickFixCmdPost    l* nested lwindow
augroup end

" Customize popup window colours
augroup lsp_float_colours
    autocmd!
    if !has('nvim')
        autocmd User lsp_float_opened call win_execute(lsp#ui#vim#output#getpreviewwinid(), 'setlocal wincolor=PopupWindow')
    else
        autocmd User lsp_float_opened call nvim_win_set_option(lsp#ui#vim#output#getpreviewwinid(), 'winhighlight', 'Normal:PopupWindowDark')
    endif
augroup end

" --------------------------------------------------------------------------------
" Functions
" --------------------------------------------------------------------------------

"" Autowrite LaTeX files
function! s:autowrite_latex()
    if filereadable(expand('%')) && b:vimtex.compiler.is_running()
        execute "silent update"
    endif
endfunction

"" Vimrc folding
function! VimrcFoldExpr()
    let l:thisline = getline(v:lnum)

    " Level 2 and level 3 folds
    if match(l:thisline, '^"""') >= 0
        return '>3'
    elseif match(l:thisline, '^""') >= 0
        return '>2'
    endif

    " Level 1 fold
    if line(v:lnum) + 2 <= line('$')
        let l:nextline = getline(v:lnum + 1)
        let l:nextnextline = getline(v:lnum + 2)

        if match(thisline, '^"\s*-') >= 0 && match(nextline, '^"') >= 0 && match(nextnextline, '^"\s*-') >= 0
            return '>1'
        endif
    endif

    " No fold
    return '='
endfunction

function! VimrcFoldText()
    let l:level = v:foldlevel
    let l:foldsize = v:foldend - v:foldstart
    let l:linecount = '(' . l:foldsize . (foldsize == 1 ? ' line' : ' lines') . ')'

    if l:level == 1
        let l:marker = '●'
    elseif l:level == 2
        let l:marker = '    ○'
    else
        let l:marker = '        -'
    end

    if l:level == 1
        let l:title = substitute(getline(v:foldstart + 1), '^"\s*', '', '')
    else
        let l:title = substitute(getline(v:foldstart), '^"\+\s*', '', '')
    endif

    return l:marker . ' ' . l:title . ' ' . l:linecount
endfunction

"" Toggle completeopt longest
function! s:set_completeopt_longest(enable)
    if a:enable
        set completeopt+=longest
    else
        set completeopt-=longest
    endif
    return ''
endfunction

" --------------------------------------------------------------------------------
" Local overrides
" --------------------------------------------------------------------------------

if filereadable($HOME . "/.vimrc.local")
    execute "source " . $HOME . "/.vimrc.local"
endif
