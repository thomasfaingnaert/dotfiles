" --------------------------------------------------------------------------------
" Plugin list
" --------------------------------------------------------------------------------

call plug#begin()

Plug 'iCyMind/NeoSolarized'

Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'

Plug 'tpope/vim-commentary'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-unimpaired'

Plug 'lervag/vimtex'
Plug 'machakann/vim-sandwich'
Plug 'junegunn/vim-easy-align'

Plug 'markonm/traces.vim'

Plug 'prabirshrestha/async.vim'
Plug 'prabirshrestha/vim-lsp'

call plug#end()

" --------------------------------------------------------------------------------
" General settings
" --------------------------------------------------------------------------------

"" Setup
" Load matchit
runtime macros/matchit.vim

" Enable filetype support and syntax highlighting
filetype plugin indent on
syntax enable

"" GUI options
if has('gui_running')
    set background=light
    colorscheme NeoSolarized

    " Only set guifont once, since it resizes gVim when sourcing $MYVIMRC
    if !exists('g:set_guifont')
        let g:set_guifont=1

        if has('win32')
            set guifont=Consolas:h11
        else
            set guifont=Monospace\ 11
        endif
    endif

    set guioptions-=m
    set guioptions-=T
    set guioptions-=r
    set guioptions-=L
endif

"" System-dependent directories
""" Temporary directories
if !exists('g:myruntime')
    let g:myruntime=split(&rtp, ',')[0]
end

let &backupdir=g:myruntime . '/backup//'
let &directory=g:myruntime . '/swap//'
let &undodir=g:myruntime . '/undo//'

""" Dotfiles
if !exists('g:mydotfiles')
    if has('win32')
        let g:mydotfiles = '~/dotfiles'
    else
        let g:mydotfiles = '~/.dotfiles'
    endif
end

"" Line numbers
set relativenumber
set number

"" Indentation
set shiftwidth=4
set softtabstop=4
set expandtab
set autoindent

"" Search
set hlsearch
set incsearch
set ignorecase
set smartcase

"" Statusline
set laststatus=2

set statusline=                             " clear statusline for when vimrc is reloaded
set statusline+=%f                          " path to file in the buffer
set statusline+=%(\ %h%)                    " help flag: [Help] or empty
set statusline+=%(\ %m%)                    " modified flag: [+] or [-] or empty
set statusline+=%(\ %r%)                    " readonly flag: [RO] or empty
set statusline+=%(\ (%{fugitive#head()})%)  " current branch
set statusline+=%=                          " right align
set statusline+=\ Line:\ %l/%L              " current line and total number of lines
set statusline+=\ Col:\ %c                  " column number

"" Other
set encoding=utf-8
set listchars=eol:¬,tab:▸\ ,trail:·,precedes:←,extends:→
set backspace=indent,eol,start
set wildmenu
set wildcharm=<C-z>
set scrolloff=5
set sidescrolloff=5
set formatoptions+=j
set hidden
set lazyredraw
set autoread
set spelllang=en_gb

" Set shell to cmd.exe (this is needed to use gVim as difftool in Windows)
if has('win32')
    set shell=C:\WINDOWS\system32\cmd.exe
endif

" --------------------------------------------------------------------------------
" Plugin settings
" --------------------------------------------------------------------------------

"" UltiSnips
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
let g:UltiSnipsEditSplit="vertical"

"" vim-tex
" Use LaTeX by default
let g:tex_flavor="latex"

" Don't automatically open/close the quickfix window in tex files
" When using autowrite and latexmk pvc, it is annoying and it breaks
" UltiSnips
let g:vimtex_quickfix_mode=0

" Use SumatraPDF in Windows
if has('win32')
    let g:vimtex_view_general_viewer='SumatraPDF'
    let g:vimtex_view_general_options
                \ = '-reuse-instance -forward-search @tex @line @pdf'
                \ . ' -inverse-search "' . $VIMRUNTIME . '\gvim.exe --servername ' . v:servername
                \ . ' --remote-silent +\%l \%f"'
    let g:vimtex_view_general_options_latexmk='-reuse-instance'
endif

"" vim-sandwich
" I prefer vim-surround keymappings
runtime macros/sandwich/keymap/surround.vim

"" vim-lsp
" Seems this is needed for clangd to provide correct completions
let g:lsp_async_completion=1

" --------------------------------------------------------------------------------
" Mappings
" --------------------------------------------------------------------------------

"" Allow undoing C-u and C-w in insert mode
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>

"" Window navigation and movement
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

nnoremap <M-h> <C-w>H
nnoremap <M-j> <C-w>J
nnoremap <M-k> <C-w>K
nnoremap <M-l> <C-w>L

"" Leader
let mapleader=" "
let maplocalleader="\\"

nnoremap <leader>e :browse edit<CR>
nnoremap <leader>w :update<CR>
nnoremap <leader>v :execute ':edit ' . g:mydotfiles . '/vim/vimrc'<CR>
nnoremap <leader>r :source $MYVIMRC<CR>
nnoremap <leader>l :set list!<CR>
nnoremap <leader>h :nohlsearch<CR>
nnoremap <leader>= :call <SID>Preserve("normal gg=G")<CR>
nnoremap <leader>c :lcd %:h<CR>
nnoremap <leader>p :set spell!<CR>:set spell?<CR>

" Deselect selected wildmenu option, if any
cnoremap <expr> <C-x> wildmenumode() ? "\<S-Tab>" : ""

nmap <leader>b :ls<CR>:buffer <C-z><C-x>
nmap <leader>s :ls<CR>:vert sbuffer <C-z><C-x>
nmap <leader>d :ls<CR>:bdelete <C-z><C-x>


"" Fugitive
nnoremap <leader>gs :Gstatus<CR>
nnoremap <leader>ge :Gedit<CR>
nnoremap <leader>gw :Gwrite<CR>
nnoremap <leader>gr :Gread<CR>
nnoremap <leader>gp :Gpush<CR>
nnoremap <leader>gc :Glcd<CR>

"" Easy align
nmap ga <Plug>(EasyAlign)
xmap ga <Plug>(EasyAlign)

"" Make
nnoremap <F7> :make<CR>

"" Emacs-style command-line editing
" See :h emacs-keys
" start of line
cnoremap <C-A>		<Home>
" back one character
cnoremap <C-B>		<Left>
" delete character under cursor
cnoremap <C-D>		<Del>
" end of line
cnoremap <C-E>		<End>
" forward one character
cnoremap <C-F>		<Right>
" recall newer command-line
cnoremap <C-N>		<Down>
" recall previous (older) command-line
cnoremap <C-P>		<Up>
" back one word
cnoremap <Esc><C-B>	<S-Left>
" forward one word
cnoremap <Esc><C-F>	<S-Right>

"" Faster search and replace
nnoremap <leader><leader> :'{,'}s/\<<C-r><C-w>\>//g<Left><Left>
nnoremap <leader>% :%s/\<<C-r><C-w>\>//g<Left><Left>

"" Quickly switch between alternate files
nnoremap <BS> <C-^>

"" Don't fill in completion with omnicompletion
inoremap <expr> <SID>CompleteOptLongestOff CompleteOptLongest(0)
inoremap <expr> <SID>CompleteOptLongestOn CompleteOptLongest(1)
inoremap <script> <C-x><C-o> <SID>CompleteOptLongestOn<C-x><C-o><SID>CompleteOptLongestOff


" --------------------------------------------------------------------------------
" Autocommands
" --------------------------------------------------------------------------------

"" Update make mappings
augroup update_make_mappings
    autocmd!
    autocmd BufWinEnter * call SetMakeMappings()
augroup end

"" Automatically strip whitespace
augroup strip_whitespace
    autocmd!
    autocmd BufWritePre * :call<SID>Preserve("%s/\\s\\+$//e")
augroup end

"" Don't automatically continue comment when pressing enter
augroup no_continue_comment
    autocmd!
    autocmd FileType * setlocal formatoptions-=r
augroup end

"" Ruby - two space indentation
augroup ruby_indentation
    autocmd!
    autocmd FileType ruby setlocal shiftwidth=2 softtabstop=2
augroup end

"" LaTeX - autowrite files
augroup autowrite_latex_files
    autocmd!
    autocmd FileType tex :autocmd! autowrite_latex_files TextChanged,TextChangedI <buffer> call AutowriteLatex()
augroup end

"" Automatically source vimrc
augroup auto_source_vimrc
    autocmd!
    execute 'autocmd BufWritePost ' . g:mydotfiles . '/vim/vimrc' . ' source $MYVIMRC'
augroup end

"" Language server protocol (vim-lsp)
""" Python
" pip install python-language-server
if executable('pyls')
    augroup vim_lsp_python
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'pyls',
                    \ 'cmd': {server_info->['pyls']},
                    \ 'whitelist': ['python'],
                    \ })
        autocmd FileType python setlocal omnifunc=lsp#complete
        autocmd FileType python setlocal keywordprg=:LspHover
        autocmd FileType python nnoremap <buffer> <C-]> :LspDefinition<CR>
    augroup end
endif

""" C++
" Windows: http://releases.llvm.org/download.html
" Ubuntu:
" sudo apt install clang-tools
" sudo update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-6.0 100
if executable('clangd')
    augroup vim_lsp_cpp
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'clangd',
                    \ 'cmd': {server_info->['clangd']},
                    \ 'whitelist': ['c', 'cpp', 'objc', 'objcpp', 'cc'],
                    \ })
        autocmd FileType c,cpp,objc,objcpp,cc setlocal omnifunc=lsp#complete
        autocmd FileType c,cpp,objc,objcpp,cc setlocal keywordprg=:LspHover
        autocmd FileType c,cpp,objc,objcpp,cc nnoremap <buffer> <C-]> :LspDefinition<CR>
        autocmd FileType c,cpp,objc,objcpp,cc nnoremap <buffer> <F2> :LspRename<CR>
    augroup end
endif

" --------------------------------------------------------------------------------
" Functions
" --------------------------------------------------------------------------------

"" Set custom :make mappings
function! SetMakeMappings()
    " Check if a file named "Makefile" exists in the directory of the current
    " buffer
    if filereadable(expand("%:p:h") . "/Makefile")
        set makeprg=make
        nnoremap <F5> :make debug<CR>
        nnoremap <F6> :make run<CR>
    else
        if has('win32')
            set makeprg=build-system\build
            nnoremap <F5> :make<CR>:silent !build-system\debug<CR>
            nnoremap <F6> :make<CR>:silent !build-system\run<CR>
        else
            set makeprg=./build-system/build.sh
            nnoremap <F5> :make<CR>:silent !./build-system/debug.sh<CR>
            nnoremap <F6> :make<CR>:silent !./build-system/run.sh<CR>
        end
    endif
endfunction

"" Preserve "state" and execute command
" (Source: http://vimcasts.org/episodes/tidying-whitespace/)
function! <SID>Preserve(command)
    let l:win_view = winsaveview()
    let l:last_search = getreg('/')
    execute 'keepjumps ' . a:command
    call winrestview(l:win_view)
    call setreg('/', l:last_search)
endfunction

"" Autowrite LaTeX files
function! AutowriteLatex()
    if filereadable(expand('%')) && b:vimtex.compiler.is_running()
        execute "silent update"
    endif
endfunction

"" Vimrc folding
function! VimrcFoldExpr()
    let l:thisline = getline(v:lnum)

    " Level 2 and level 3 folds
    if match(l:thisline, '^"""') >= 0
        return '>3'
    elseif match(l:thisline, '^""') >= 0
        return '>2'
    endif

    " Level 1 fold
    if line(v:lnum) + 2 <= line('$')
        let l:nextline = getline(v:lnum + 1)
        let l:nextnextline = getline(v:lnum + 2)

        if match(thisline, '^"\s*-') >= 0 && match(nextline, '^"') >= 0 && match(nextnextline, '^"\s*-') >= 0
            return '>1'
        endif
    endif

    " No fold
    return '='
endfunction

function! VimrcFoldText()
    let l:level = v:foldlevel
    let l:foldsize = v:foldend - v:foldstart
    let l:linecount = '(' . l:foldsize . (foldsize == 1 ? ' line' : ' lines') . ')'

    if l:level == 1
        let l:marker = '●'
    elseif l:level == 2
        let l:marker = '    ○'
    else
        let l:marker = '        -'
    end

    if l:level == 1
        let l:title = substitute(getline(v:foldstart + 1), '^"\s*', '', '')
    else
        let l:title = substitute(getline(v:foldstart), '^"\+\s*', '', '')
    endif

    return l:marker . ' ' . l:title . ' ' . l:linecount
endfunction

"" Toggle completeopt longest
function! CompleteOptLongest(enable)
    if a:enable
        set completeopt+=longest
    else
        set completeopt-=longest
    endif
    return ''
endfunction

" --------------------------------------------------------------------------------
" Local overrides and modeline
" --------------------------------------------------------------------------------

if filereadable($HOME . "/.vimrc.local")
    execute "source " . $HOME . "/.vimrc.local"
endif

" vim: foldmethod=expr foldexpr=VimrcFoldExpr() foldtext=VimrcFoldText()
