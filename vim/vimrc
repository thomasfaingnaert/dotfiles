" --------------------------------------------------------------------------------
" Plugin list
" --------------------------------------------------------------------------------

call plug#begin()

Plug 'iCyMind/NeoSolarized'

Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'

Plug 'tpope/vim-commentary'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-projectionist'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-rhubarb'
Plug 'tpope/vim-unimpaired'

Plug 'lervag/vimtex'
Plug 'machakann/vim-sandwich'
Plug 'junegunn/vim-easy-align'

Plug 'christoomey/vim-sort-motion'
Plug 'markonm/traces.vim'

Plug 'prabirshrestha/asyncomplete.vim'
Plug 'prabirshrestha/async.vim'
Plug 'prabirshrestha/vim-lsp'
Plug 'prabirshrestha/asyncomplete-lsp.vim'

Plug 'thomasfaingnaert/vim-lsp-snippets'
Plug 'thomasfaingnaert/vim-lsp-ultisnips'

Plug 'vim-scripts/DoxygenToolkit.vim'

call plug#end()

" --------------------------------------------------------------------------------
" General settings
" --------------------------------------------------------------------------------

"" Setup
" Load matchit
packadd! matchit

" Enable filetype support and syntax highlighting
filetype plugin indent on
syntax enable

"" GUI options
if has('gui_running')
    set background=light
    colorscheme NeoSolarized

    " Only set guifont once, since it resizes gVim when sourcing $MYVIMRC
    if !exists('s:set_guifont')
        let s:set_guifont = 1

        if has('win32')
            set guifont=Consolas:h11
        else
            set guifont=Monospace\ 11
        endif
    endif

    set guioptions-=m
    set guioptions-=T
    set guioptions-=r
    set guioptions-=L
endif

"" System-dependent settings
""" Temporary directories
if !exists('g:myruntime')
    let g:myruntime = split(&rtp, ',')[0]
end

let &backupdir = g:myruntime . '/backup//'
let &directory = g:myruntime . '/swap//'
let &undodir = g:myruntime . '/undo//'

""" Dotfiles
if !exists('g:mydotfiles')
    if has('win32')
        let g:mydotfiles = '~/dotfiles'
    else
        let g:mydotfiles = '~/.dotfiles'
    endif
end

"" Line numbers
set relativenumber
set number

"" Indentation
set shiftwidth=4
set softtabstop=4
set expandtab
set autoindent

"" Search
set hlsearch
set incsearch
set ignorecase
set smartcase

"" Statusline
set laststatus=2

set statusline=                             " clear statusline for when vimrc is reloaded
set statusline+=%f                          " path to file in the buffer
set statusline+=%(\ %h%)                    " help flag: [Help] or empty
set statusline+=%(\ %m%)                    " modified flag: [+] or [-] or empty
set statusline+=%(\ %r%)                    " readonly flag: [RO] or empty
set statusline+=%(\ (%{fugitive#head()})%)  " current branch
set statusline+=%=                          " right align
set statusline+=\ Line:\ %l/%L              " current line and total number of lines
set statusline+=\ Col:\ %c                  " column number

"" Other
set encoding=utf-8
set listchars=eol:¬,tab:▸\ ,trail:·,precedes:←,extends:→
set backspace=indent,eol,start
set wildmenu
set wildcharm=<C-z>
set scrolloff=5
set sidescrolloff=5
set formatoptions+=j
set hidden
set lazyredraw
set autoread
set spelllang=en_gb
set nrformats-=octal

" This fixes netrw-gx and :Gbrowse not working in gVim
let g:netrw_browsex_viewer="setsid xdg-open"

" Set shell to cmd.exe (this is needed to use gVim as difftool in Windows)
if has('win32')
    set shell=C:\WINDOWS\system32\cmd.exe
endif

"" Set wildignore
set wildignore+=*/build/*
set wildignore+=*/docs/*

"" Set clang-format options
let s:clang_format_settings = {
            \       "BasedOnStyle": "LLVM",
            \       "AccessModifierOffset": -4,
            \       "AllowShortFunctionsOnASingleLine": "Inline",
            \       "BreakBeforeBraces": "Allman",
            \       "IncludeBlocks": "Regroup",
            \       "IndentWidth": 4
            \   }

" --------------------------------------------------------------------------------
" Plugin settings
" --------------------------------------------------------------------------------

"" UltiSnips
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"
let g:UltiSnipsEditSplit = "vertical"

"" vim-tex
" Use LaTeX by default
let g:tex_flavor = "latex"

" Don't automatically open/close the quickfix window in tex files
" When using autowrite and latexmk pvc, it is annoying and it breaks
" UltiSnips
let g:vimtex_quickfix_mode = 0

" Use SumatraPDF in Windows
if has('win32')
    let g:vimtex_view_general_viewer = 'SumatraPDF'
    let g:vimtex_view_general_options
                \ = '-reuse-instance -forward-search @tex @line @pdf'
                \ . ' -inverse-search "' . $VIMRUNTIME . '\gvim.exe --servername ' . v:servername
                \ . ' --remote-silent +\%l \%f"'
    let g:vimtex_view_general_options_latexmk = '-reuse-instance'
endif

"" vim-sandwich
" I prefer vim-surround keymappings
runtime macros/sandwich/keymap/surround.vim

"" vim-sort-motion
" Ignore options when sorting \usepackage in LaTeX
let g:sort_motion_flags = ''
            \ . '/'
            \ .     '\('
            \ .         '^\\usepackage'
            \ .         '\('
            \ .             '\['
            \ .             '[^\]]*'
            \ .             '\]'
            \ .         '\)\?'
            \ .         '{'
            \ .     '\)\?'
            \ . '/'

"" vim-projectionist
let g:projectionist_heuristics = {
            \   "include/*.h|src/*.cpp": {
            \       "include/*.h": {
            \           "alternate": "src/{}.cpp",
            \           "type": "header"
            \       },
            \       "src/*.cpp": {
            \           "alternate": "include/{}.h",
            \           "type": "source"
            \       }
            \   },
            \   "*.h&*.cpp": {
            \       "*.h": {
            \           "alternate": "{}.cpp",
            \           "type": "header"
            \       },
            \       "*.cpp": {
            \           "alternate": "{}.h",
            \           "type": "source"
            \       }
            \   }}

" --------------------------------------------------------------------------------
" Mappings
" --------------------------------------------------------------------------------

"" Allow undoing C-u and C-w in insert mode
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>

"" Window navigation and movement
nnoremap <silent> <C-h> :call <SID>window_move('h')<CR>
nnoremap <silent> <C-j> :call <SID>window_move('j')<CR>
nnoremap <silent> <C-k> :call <SID>window_move('k')<CR>
nnoremap <silent> <C-l> :call <SID>window_move('l')<CR>

nnoremap <C-M-h> <C-w>H
nnoremap <C-M-j> <C-w>J
nnoremap <C-M-k> <C-w>K
nnoremap <C-M-l> <C-w>L

"" Move lines up and down
nnoremap <A-j> :move +1<CR>==
nnoremap <A-k> :move -2<CR>==

inoremap <A-j> <Esc>:move +1<CR>==gi
inoremap <A-k> <Esc>:move -2<CR>==gi

xnoremap <A-j> :move '>+1<CR>gv=gv
xnoremap <A-k> :move '<-2<CR>gv=gv

"" Leader
let mapleader = " "
let maplocalleader = "\\"

nnoremap <leader>e :browse edit<CR>
nnoremap <leader>w :update<CR>
nnoremap <leader>v :execute ':edit ' . g:mydotfiles . '/vim/vimrc'<CR>
nnoremap <leader>r :source $MYVIMRC<CR>
nnoremap <leader>l :set list!<CR>
nnoremap <leader>h :nohlsearch<CR>
nnoremap <leader>= :call <SID>preserve_state("normal gg=G")<CR>
nnoremap <leader>c :lcd %:h<CR>
nnoremap <leader>p :set spell!<CR>:set spell?<CR>

" Deselect selected wildmenu option, if any
cnoremap <expr> <SID>deselect_wildmenu_option wildmenumode() ? "\<S-Tab>" : ""

nmap <leader>b :ls<CR>:buffer <C-z><SID>deselect_wildmenu_option
nmap <leader>s :ls<CR>:vert sbuffer <C-z><SID>deselect_wildmenu_option
nmap <leader>d :ls<CR>:bdelete <C-z><SID>deselect_wildmenu_option


"" Fugitive
nnoremap <leader>gs :Gstatus<CR>
nnoremap <leader>ge :Gedit<CR>
nnoremap <leader>gw :Gwrite<CR>
nnoremap <leader>gr :Gread<CR>
nnoremap <leader>gp :Gpush<CR>
nnoremap <leader>gc :Glcd<CR>
nnoremap <leader>gb :Gbrowse<CR>

"" Easy align
nmap ga <Plug>(EasyAlign)
xmap ga <Plug>(EasyAlign)

"" Make
nnoremap <silent> <F7> :call <SID>make_application()<CR>

"" Emacs-style command-line editing
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-n> <Down>
cnoremap <C-p> <Up>

"" Faster search and replace
nmap <silent> <Space><Space> :call <SID>save_word()<CR>:set operatorfunc=<SID>quick_replace<CR>g@
vmap <silent> <Space><Space> :<C-u>call <SID>quick_replace(visualmode(), 1)<CR>

nnoremap v :call <SID>save_word()<CR>v
nnoremap V :call <SID>save_word()<CR>V
nnoremap <C-v> :call <SID>save_word()<CR><C-v>

function! s:save_word()
    let s:word = expand('<cword>')
endfunction

function! s:quick_replace(type, ...)
    if a:0
        call feedkeys(":'<,'>s/\\<" . s:word . "\\>//g\<Left>\<Left>")
    else
        call feedkeys(":'[,']s/\\<" . s:word . "\\>//g\<Left>\<Left>")
    endif
endfunction

"" Quickly switch between alternate files
nnoremap <BS> :A<CR>

"" Don't fill in completion with omnicompletion
inoremap <expr> <SID>completeopt_longest_off <SID>set_completeopt_longest(0)
inoremap <expr> <SID>completeopt_longest_on <SID>set_completeopt_longest(1)
inoremap <script> <C-x><C-o> <SID>completeopt_longest_on<C-x><C-o><SID>completeopt_longest_off

"" Increase and reset font size
nnoremap <M-+> :call <SID>increase_font_size(+1)<CR>
nnoremap <M--> :call <SID>increase_font_size(-1)<CR>
nnoremap <M-=> :call <SID>reset_font_size()<CR>

"" Format paragraph so all sentences are on a different line
nnoremap Q :set operatorfunc=<SID>format_paragraph<CR>g@
vnoremap Q :<C-u>call <SID>format_paragraph(visualmode(), 1)<CR>

"" Underline current line
nnoremap <silent> <leader>u :call <SID>underline(0)<CR>
nnoremap <silent> <leader>U :call <SID>underline(1)<CR>

" --------------------------------------------------------------------------------
" Autocommands
" --------------------------------------------------------------------------------

"" Automatically strip whitespace
augroup strip_whitespace
    autocmd!
    autocmd BufWritePre * call <SID>preserve_state("%s/\\s\\+$//e")
augroup end

"" Don't automatically continue comment when pressing enter
augroup no_continue_comment
    autocmd!
    autocmd FileType * setlocal formatoptions-=r
augroup end

"" Ruby - two space indentation
augroup ruby_indentation
    autocmd!
    autocmd FileType ruby setlocal shiftwidth=2 softtabstop=2
augroup end

"" LaTeX - autowrite files
augroup autowrite_latex_files
    autocmd!
    autocmd FileType tex autocmd! autowrite_latex_files CursorHold,CursorHoldI <buffer> call <SID>autowrite_latex()
augroup end

"" LaTeX - auto sort usepackage
augroup autosort_latex_usepackage
    autocmd!
    autocmd FileType tex autocmd! autosort_latex_usepackage BufWritePre <buffer> call <SID>preserve_state('g/\n\n^\\usepackage/+2 normal gsip')
augroup end

"" Automatically source vimrc
augroup auto_source_vimrc
    autocmd!
    execute 'autocmd BufWritePost ' . g:mydotfiles . '/vim/vimrc' . ' source $MYVIMRC'
augroup end

"" Language server protocol (vim-lsp)
""" Python
" pip install python-language-server
if executable('pyls')
    augroup vim_lsp_python
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'pyls',
                    \ 'cmd': {server_info->['pyls']},
                    \ 'whitelist': ['python'],
                    \ })
        autocmd FileType python setlocal omnifunc=lsp#complete
        autocmd FileType python setlocal keywordprg=:LspHover
        autocmd FileType python nnoremap <buffer> <C-]> :LspDefinition<CR>
    augroup end
endif

""" C++
" Windows: http://releases.llvm.org/download.html
" Ubuntu:
" sudo apt install clang-tools-7
" sudo update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-7 100
if executable('clangd')
    augroup vim_lsp_cpp
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'clangd',
                    \ 'cmd': {server_info->['clangd']},
                    \ 'whitelist': ['c', 'cpp', 'objc', 'objcpp', 'cc'],
                    \ })
        autocmd FileType c,cpp,objc,objcpp,cc setlocal omnifunc=lsp#complete
        autocmd FileType c,cpp,objc,objcpp,cc setlocal keywordprg=:LspHover
        autocmd FileType c,cpp,objc,objcpp,cc nnoremap <buffer> <C-]> :LspDefinition<CR>
        autocmd FileType c,cpp,objc,objcpp,cc nnoremap <buffer> <F2> :LspRename<CR>
    augroup end
endif

"" C++ formatting
augroup cpp_auto_format
    autocmd!
    autocmd FileType c,cpp let &l:equalprg = "clang-format -style='" . json_encode(s:clang_format_settings) . "'"
    autocmd FileType c,cpp autocmd BufWritePre <buffer> call <SID>preserve_state("normal gg=G")
augroup end

"" Asciidoc - comments
augroup asciidoc_comments
    autocmd!
    autocmd FileType asciidoc setlocal commentstring=//\ %s
augroup end

"" Automatically open quickfix
augroup auto_open_quickfix
    autocmd!
    autocmd QuickFixCmdPost [^l]* nested cwindow
    autocmd QuickFixCmdPost    l* nested lwindow
augroup end

" --------------------------------------------------------------------------------
" Functions
" --------------------------------------------------------------------------------

"" Preserve "state" and execute command
" (Source: http://vimcasts.org/episodes/tidying-whitespace/)
function! s:preserve_state(command)
    let l:win_view = winsaveview()
    let l:last_search = getreg('/')
    execute 'keepjumps ' . a:command
    call winrestview(l:win_view)
    call setreg('/', l:last_search)
endfunction

"" Autowrite LaTeX files
function! s:autowrite_latex()
    if filereadable(expand('%')) && b:vimtex.compiler.is_running()
        execute "silent update"
    endif
endfunction

"" Vimrc folding
function! VimrcFoldExpr()
    let l:thisline = getline(v:lnum)

    " Level 2 and level 3 folds
    if match(l:thisline, '^"""') >= 0
        return '>3'
    elseif match(l:thisline, '^""') >= 0
        return '>2'
    endif

    " Level 1 fold
    if line(v:lnum) + 2 <= line('$')
        let l:nextline = getline(v:lnum + 1)
        let l:nextnextline = getline(v:lnum + 2)

        if match(thisline, '^"\s*-') >= 0 && match(nextline, '^"') >= 0 && match(nextnextline, '^"\s*-') >= 0
            return '>1'
        endif
    endif

    " No fold
    return '='
endfunction

function! VimrcFoldText()
    let l:level = v:foldlevel
    let l:foldsize = v:foldend - v:foldstart
    let l:linecount = '(' . l:foldsize . (foldsize == 1 ? ' line' : ' lines') . ')'

    if l:level == 1
        let l:marker = '●'
    elseif l:level == 2
        let l:marker = '    ○'
    else
        let l:marker = '        -'
    end

    if l:level == 1
        let l:title = substitute(getline(v:foldstart + 1), '^"\s*', '', '')
    else
        let l:title = substitute(getline(v:foldstart), '^"\+\s*', '', '')
    endif

    return l:marker . ' ' . l:title . ' ' . l:linecount
endfunction

"" Toggle completeopt longest
function! s:set_completeopt_longest(enable)
    if a:enable
        set completeopt+=longest
    else
        set completeopt-=longest
    endif
    return ''
endfunction

"" Make and run current application
function! s:make_application() abort
    " Clear screen
    if has('win32')
        silent !cls
    else
        silent !clear
    endif

    " Build and run the project (filetype dependent)
    if &filetype == 'python'
        !python %
    elseif &filetype == 'sh'
        !bash %
    elseif &filetype == 'vim'
        source %
    else
        make
    endif
endfunction

"" Increase and reset font size
if !exists("s:default_font")
    let s:default_font = &guifont
endif

function! s:increase_font_size(amount)
    let l:min_font_size = 8
    let l:max_font_size = 60

    if has('win32')
        let l:pattern = '^\(.*:h\)\([1-9][0-9]*\)$'
    else
        let l:pattern = '^\(.* \)\([1-9][0-9]*\)$'
    endif

    let l:font = substitute(&guifont, l:pattern, '\1', '')
    let l:size = substitute(&guifont, l:pattern, '\2', '')
    let l:new_size = l:size + a:amount

    if (l:new_size >= l:min_font_size) && (l:new_size <= l:max_font_size)
        let &guifont = l:font . l:new_size
    endif

    set lines=999 columns=999
endfunction

function! s:reset_font_size()
    let &guifont = s:default_font
    set lines=999 columns=999
endfunction

"" Format paragraph: all sentences on new line
function! s:format_paragraph(type, ...)
    " Join all lines, taking care to not remove paragraph breaks.
    " This is accomplished by only joining lines with at least one non-space
    " character.
    silent '[,']s/\(\S\s*\)\n\(\s*\S\)/\1 \2/ge

    " Add a linebreak after all punctuation (.?!) followed by at least one
    " space and a capital letter, and remove that whitespace.
    silent '[,']s/\([.?!]\)\s\+\ze[A-Z]/\1\r/ge
endfunction

"" Underline current line
function! s:underline(above) abort
    " Save cursor position
    let l:pos = getcurpos()

    " Prompt for character to underline with
    let l:char = getchar()

    " Use <Esc> to cancel
    if l:char != 27
        " Underline current line with chosen character
        if a:above
            execute "t-1 \| snomagic/\\./" . nr2char(l:char) . "/ge"

            " Because of the extra line, we want the cursor one down
            let l:pos[1] += 1
        else
            execute "t. \| snomagic/\\./" . nr2char(l:char) . "/ge"
        endif
    endif

    " Restore cursor position
    call setpos('.', l:pos)
endfunction

"" Move/create window
" Source:
" http://www.agillo.net/simple-vim-window-management/
" https://aonemd.github.io/blog/handy-keymaps-in-vim

function! s:window_move(key)
    " Save old window
    let l:current_window = winnr()

    " Execute movement
    execute "wincmd " . a:key

    " Check if we have changed window
    if (l:current_window == winnr())
        " If not, create a new split
        if (a:key =~# '[hl]')
            wincmd v
        else
            wincmd s
        endif

        " Move to that new split
        execute "wincmd " . a:key
    endif
endfunction

" --------------------------------------------------------------------------------
" Local overrides and modeline
" --------------------------------------------------------------------------------

if filereadable($HOME . "/.vimrc.local")
    execute "source " . $HOME . "/.vimrc.local"
endif

" vim: foldmethod=expr foldexpr=VimrcFoldExpr() foldtext=VimrcFoldText()
